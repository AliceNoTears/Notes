#### 创建索引
`CREATE INDEX indexName ON mytable(username(length)); `
`ALTER table tableName ADD INDEX indexName(columnName)`
#### 删除索引
`DROP INDEX [indexName] ON mytable; `
#### 显示索引信息
`SHOW INDEX FROM table_name;`

### MySQL中能够使用索引的典型场景
- 匹配全值（对索引中的所有列都有等值匹配的条件）
- 匹配值的范围查询(对索引的值能够进行范围查找)
- 匹配最左前缀(仅仅使用索引中的最左边列进行查找)
- 仅仅对索引进行查询(查询的列都在索引的字段中)
- 匹配列前缀(仅仅使用索引中的第一列，并且只包含索引第一列的开头一部分进行查找)
- 能够实现索引匹配部分精确而其它部分进行范围查询
- 如果列名是索引，那么使用where column_name is null 会使用到索引

### 存在索引但不能使用索引的典型场景
- 以%开头的LIKE查询不能使用B-Tree索引
- 数据类型出现隐式转换的时候也不能使用索引(特别是当列类型是字符串，一定要在where条件中把字符常量用引号括起来)
- 符合索引的情况下，假如查询条件不包含索引的最左部分，即不满足最左原则，是不会使用复合索引的
- 如果MySQL估计使用索引比不使用索引慢，就不会使用索引
- 用or分割开的条件，如果or前的条件中的列有索引，而后面的列没有索引，那么涉及的索引不会被用到
